\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography

\usepackage{url}
\usepackage[table]{xcolor}
\usepackage{bbm}
\usepackage{booktabs}
\usepackage[T1]{fontenc}
\usepackage{fix-cm}
\usepackage{array}
\usepackage{epsfig}
%\usepackage{mathabx}
\usepackage{dsfont}
\usepackage{multirow}

\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{bm}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{mathrsfs}
\usepackage{array}

% Include other packages here, before hyperref.

% If you comment hyperref and then uncomment it, you should delete
% egpaper.aux before re-running latex.  (Or just hit 'q' on the first latex
% run, let it finish, and you should be clear).
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

% \cvprfinalcopy % *** Uncomment this line for the final submission
\newcommand{\figref}[1]{Fig\onedot~\ref{#1}}
\newcommand{\equref}[1]{Eq\onedot~\eqref{#1}}
\newcommand{\secref}[1]{Sec\onedot~\ref{#1}}
\newcommand{\tabref}[1]{Tab\onedot~\ref{#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\prgref}[1]{Program~\ref{#1}}
\newcommand{\algref}[1]{Alg\onedot~\ref{#1}}
\newcommand{\clmref}[1]{Claim~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\ptyref}[1]{Property\onedot~\ref{#1}}

\newcommand{\ve}[1]{{\mathbf #1}} % for displaying a vector or matrix
\newcommand{\hua}[1]{{\mathcal #1}}
\newcommand{\scr}[1]{{\mathcal #1}}
\newcommand{\by}[2]{\ensuremath{#1 \! \times \! #2}}

%\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\onedot{\ifx\@let@token.\else.\null\fi\xspace}
\def\eg{\emph{e.g.}} 
\def\Eg{\emph{E.g}\onedot}
\def\any{\forall}
\def\ie{\emph{i.e.}} 
\def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{cf}\onedot} 
\def\Cf{\emph{Cf}\onedot}
\def\etc{\emph{etc}\onedot} 
\def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} 
\def\dof{d.o.f\onedot}
\def\etal{\emph{et al.}}

\def\cvprPaperID{936} % *** Enter the CVPR Paper ID here
\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
\ifcvprfinal\pagestyle{empty}\fi
\begin{document}

%%%%%%%%% TITLE
\title{DeepLocSeg: 6-DOF Camera Pose Estimation and Scene Parsing with 3D Semantic Map and Deep CNN}

\maketitle
%\thispagestyle{empty}

%%%%%%%%% ABSTRACT
\begin{abstract}
Visual-based outdoor navigation requires accurately localizing the camera and preferably per-pixel semantic understanding. It can be widely applied for autonomous driving, or augment reality navigation \etc.
%However, system solely relying on visual signal is non-robust due to visual confusion across multiple scenes. 
%Thus, coarse signals from motion sensors, \eg GPS and IMU, are usually considered as a localization prior~\cite{}.
In this paper, we propose a deep learning based method for localizing the camera and parsing the recorded video simultaneously in a single framework, which fuses signals from camera and motion sensors like GPU and IOU.
Specifically, assuming we have a 3D semantic world, and the testing video is recording inside. Rough pose signal is also obtained online. In our system, for each frame in a moving camera, based on the obtained coarse pose signal, we render a label map out from our 3D world online, and feed it to a pose CNN jointly with the current frame of image, yielding a corrected pose. 
Then, a multi-layer recurrent neural network (RNN) is performed afterwards in order to capture high-order temporal information. 
Finally, a new label map is rendered again based on the corrected pose, which is feed into a segment CNN combining with the image.
In order to perform the experiments,  we built a dataset with a semantic labeled real world 3D map, jointly with many recorded videos with ground truth pose from high accurate motion sensors. We show that firstly, in a relative large environment, unlike the PoseNet~\cite{}, it is important to have a reference coarse pose signal. In addition, semantic information and pose are mutually beneficial in learning more robust networks. Finally, various ablation studies are performed, which demonstrate the effectiveness of the proposed system.
\end{abstract}

%%%%%%%%% BODY TEXT
\section{Introduction}
\label{sec:introduction}
% the problem we are solving, distinguish with previous problems
In the applications like car navigation, due to the inaccuracy from motion sensors from mobile GPS and IMU, outdoor visual-based 6-DOF camera pose estimation and scene parsing~\cite{} are attracting much attention in the community of computer vision. 
Additionally, to acquire better scene understanding for applications like augment reality navigation~\cite{}, parsing each frame of a video is also important.

% existing methods only consider one of the tasks with soly visual signal. 
Currently, most existing vision algorithms are trying to solve both of the tasks solely depend on visual signals. 
For instances, in camera localization, geometric based methods are relying visual feature tracking, \eg systems of SLAM~\cite{}, PTAM~\cite{} and 
DTAM~\cite{}, where the environment point cloud is reconstructed during the localization. Such systems could be confused of the environment scale and also can not work when staic videos or a single image is provided.
To handle such senarios, visual feature matching or point cloud matching are oftenly used, \eg system of Perspective-n-Points (PnP)~\cite{}, or patch matching~\cite{}. 
Most recently, deep learning based methods, \eg either for images~\cite{} or videos~\cite{}, are also proposed for real-time localization, which show superior accuracy and speed tradeoff.
Nevertheless, single view methods are especially for specified feature rich landmarks, \eg, Cambridge buidings~\cite{}, while could easily fail for street views with very similar appearances.

For scene parsing, approaches~\cite{} based on deep fully convolutional network (FCN)~\cite{} and ResNet~\cite{} are the best algorithms for either single image or multiple frames according to Dataset like CityScape~\cite{}. For video inputs, recent works~\cite{} also try to incorporate the optical flow between consecutive frames, in order to accelerate the parsing and build the consistency along the temperal dimension.
However, since the camera is recording the same 3D scene, higher order relationship beyond nearby frame should also be considered.
In order to jointly consider parsing and 3D, prior arts~\cite{} before deep-learning try to do it typically by first do the reconstruction with structure-from-motion (SFM)~\cite{} and then parsing the images, 
 whereas the accuracy of reconstructed 3D from street-view images is limited for real applications.

In our scenario, targeting at a more practical system setting, in addition to online recorded video, for handling the localization confusion of street views, we propose to fuse the coarse GPS and IMU motion signal from corresponding device, which is typically available for current navigation system. Those signals can serve as a pose priori for our deep learning system. 
For video segmentation, in order to have 3D relationships between different frames, we pre-build a high resolution semantic 3D map based on high accurate LIDAR points recorded by Riegl~\cite{}, which helps construct the correlation in-between multiple frames through the estimated poses. 
In fact, our setting is realistic when compare with the widely applied commercial navigation system, such as Google Map~\cite{}, we raise the 2D road map to a 3D world, and try to online estimate the 3D camera pose rather than 2D. For 3D map, city scale 3D map has largely already collected from comany like Google Earth~\cite{} and Altzure~\cite{}, and also semantic labeled ones is also built such as Toronto city~\cite{}.

Finally, within such a framework, the pose estimation and scene parsing could be jointly modeled, where pose can help build the correlation between different frames, and reversely, semantics could help align camera poses, yielding better results for both tasks than doing them individually. In our experiments, our system estimates the pose in 10ms with accuracy under 1 degree, and segments the image $512 \times 608$ in less than 100ms with pixel accuracy around 96$\%$, which demonstrates its efficiency and effectiveness.

\begin{figure*}[t]
\fbox{\rule{0pt}{2in} \rule{.9\linewidth}{0pt}}
   \caption{Framework of our proposed system. The black arrows show the testing process and red arrows show the back-propagation in training.}
\label{fig:framework}
\end{figure*}

% redefine our problem
In summary, the contributions of this paper are in three folds:
\begin{itemize}
    \item We propose a deep learning based method for fusing multiple sensors, \ie camera, GPS and IMU, which significantly improves the accuracy of awared visual tasks, \ie camera localization and scene parsing.
    \item We build a system that jointly do 6-DOF camera pose estimate and semantic parsing based on a deep learning strategy, where two kinds of information are mutually beneficial inside.
    \item To perform the experiments, we apply our system to a dataset recorded from real scene with dense 3D point cloud, ground truth camera poses and pixel-level parsing of every frame, which helps to evaluate the system and hopefully benefit the correlated research field in computer vision.
\end{itemize}

The structure of this paper is organized as follows. In \secref{sec:data_collection}, we first describe how our data is different from the existing outdoor datasets. In addition, we briefly introduce the method how the data is collect and labelled. Then, \secref{sec:localize_and_parsing} presents the framework and detail of our system. The full performance is evaluated quantitatively for both pose estimation and parsing in \secref{sec:experiments}, and \secref{sec:conclusion} concludes the paper and point out future directions. Finally, We will release all our code, models and dataset with the publication of this paper.


\subsection{Framework}
\label{sub:framework}
The framework of our system is illustrated in \figref{fig:framework}. At above, a pre-built 3D semantic map is prepared. During testing, an online stream of images and corresponding camera poses are fed in to the system. Firstly, for each frame, a semantic label map is rendered out based on the obtained coarse camera pose. Then it is fed to a pose network jointly with the respective image.  The network calculates their relative rotation and translation, and yields a corrected camera pose. To build the temporal correlations, the corrected poses are fed into a RNN which further improve the pose accuracy in the stream. 
Last, given the rectified camera pose, a new rendered label map is generated. We feed it together with the image to a segmentation network, which helps to segment a spatially more accurate and temporally more consistent result for the stream of video. 
In this system, since our data contains ground truth for both pose and segments, it can be trained with strong supervision at each end of outputs.

\section{Related work}
\label{sec:related_work}
Estimating camera pose and parsing images with a video or a single image have long been center problems for computer vision and robotics. 
Here we summarize the correlated works in several aspect without enumerating all works in this field due to space limitation.
\textbf{Structure from motion and PnP.}
\textbf{Joint 2D-3D for reconstruction and parsing.}
\textbf{Fusing sensors from GPS and camera.}
\textbf{Deep learning for camera pose and scene parsing.}
% traditional key points, slam etc
% pnp
% marc's paper
% hongdong's paper
% posenet related
% iccv kalman 
% domain transfer etc


\section{Build the data}
\label{sec:data_collection}

\paragraph{Motivation.}
As described in the \secref{sub:framework}, our system is performed with available motion sensors and a semantic 3D map. 
However, similar outdoor dataset produced by prior arts such as KITTI and CityScapes, does not containing such information. As summarized in \tabref{tbl:data}, we list several key properties to perform our experiments. 
As can be seen, existing ones do not satisfy our requirements, especially for pose estimation, for training, we want the recorded video to roughly cover the 3D environment, so that when new images come in, appearance similar views had been seen during training. This means repeated recording at similar spatial locations are required in the data, which we call temporal variations in \tabref{tbl:data}.
However, most existing datasets are a temporal snapshot at some locations in the environment, which require us to collect a new dataset ourselves.

\begin{table*}[t]
\center
\begin{tabular}{lccccc}
\toprule[0.2 em]
% \thickhline
Dataset & Real Data & Camera pose & 3D map & Video per-frame labeling  & Temporal variations  \\ 
\hline 
\multicolumn{1}{l|}{CamVid~\cite{}}     &\checkmark                       & -              & -              &  -  & -  \\
\multicolumn{1}{l|}{KITTI~\cite{}}      &\checkmark  & \checkmark     & sparse points  & -   & -  \\
\multicolumn{1}{l|}{CityScapes~\cite{}} &\checkmark  & -              &  -             & selected frames & - \\
\multicolumn{1}{l|}{Toronto~\cite{}}    &\checkmark  & \checkmark     & sparse points  & selected pixels & - \\
\hline
\multicolumn{1}{l|}{Synthia~\cite{}}    & -          & \checkmark     & -       &\checkmark & -    \\ 
\multicolumn{1}{l|}{Play for benchmark~\cite{}} &-   & \checkmark     & -     &\checkmark & - \\
\hline 
\multicolumn{1}{l|}{Ours}              & Real        &\checkmark    &dense point cloud  & \checkmark     &  \checkmark \\
\toprule[0.2 em]
\end{tabular}
\caption{Compare our data with the other related outdoor street-view datasets for our task. 'Real Data' mean whether the data is collected from realistic world. 
'3D map' means whether it contains 3D map of the whole dataset. 'Video per-frame labeling' means whether it has per-frame per-pixel semantic label. 
'Temporal variations' mean whether the recorded video can roughly cover the whole scene, but have multiple.}
\label{tbl:data}
\vspace{-0.3\baselineskip}
\end{table*}


\begin{figure}[t]
\begin{center}
\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
\end{center}
   \caption{Compare the rendered results with and without point enlargement handled by \equref{eq:label}.}
\label{fig:render}
\end{figure}

\section{Localizing camera and scene parsing.}
\label{sec:localize_and_parsing}
As shown in \secref{sub:framework}, our full system is based on a semantic 3D map and deep CNN. In the following, we will first describe how a semantic label map is rendered from the 3D, then talk about the details of our network architecture and the loss functionals to train the system.

\paragraph{Render a label map from a camera pose.} 
Formally, given a 6-DOF camera pose $\ve{p} = [\ve{q}, \ve{t}]$, where $\ve{q}$ is the quaternion representation of rotation and $\ve{t}$ is translation, a label map can be rendered from the semantic 3D map, where z-buffer~\cite{} is applied to find the closest point at each pixel.

In our setting, the 3D map is a point cloud based environment which includes 200M points. Although the density of the point cloud is very high (one point per 2.5 centimeters within road regions), when the 3D points are far away from the camera, the projected points could be very sparse, \eg regions of buildings etc.
Thus for each point in the environment, we enlarge the 3D point to a square piece where the square size is dependent on its semantic class. Formally, for a 3D point $\ve{x}$ belonging a class $c$, the square size $s_c$ is set to be,
\begin{align}
\label{eq:square_size}
s_c \propto \frac{1}{|\hua{P}_c|}\sum_{\ve{x}\in \hua{P}_c} \min_{\ve{t}\in\hua{T}} d(\ve{x}, \ve{t})
\end{align}
where $\hua{P}_c$ is the set of 3D points belong to class $c$, and $\hua{T}$ is the set of camera locations. Then, given the proportion, we rescale the square size within a range between a minimum size and a maximum size, which is set to be $[0.025, 0.05]$.

With such a strategy, as shown by \figref{fig:render}, regions with invalid value in-between projected points are in-painted, meanwhile the the boundaries between different segments are also kept. By feeding in such a rendered map, it facilitates the CNN to better discover scene layouts both for pose estimation and scene parsing.
One may wonder why we render semantic label map rather than synthesizing an RGB image for later inputs. 
This is because intuitively label maps is invariant to color changes, which yields better boundaries reflecting the scene layout. 

\subsection{Camera Localization with motion prior}
\paragraph{Pose rectify with road prior.} 

\begin{figure}[t]
\begin{center}
\fbox{\rule{0pt}{2in} \rule{0.9\linewidth}{0pt}}
\end{center}
   \caption{The GRU RNN network architecture for modeling a sequence of camera poses.}
\label{fig:rnn}
\end{figure}

\paragraph{CNN-GRU pose network architecture.} 
As shown in \figref{fig:framework}, the CNN of our pose network takes as inputs an image $\ve{I}$ and the rendered label map $\ve{L}^c$ from corresponding coarse camera pose $\ve{p}_i^c$. It outputs a 7 dimension vector $\hat{\ve{p}}_i$ representing the relative pose between the image and rendered label map, and the estimated pose respect the world is $\ve{p}_i = \ve{p}_i^c + \hat{\ve{p}_i}$.
For designing the network, in order to have large kernel to obtain bigger context while keeping the amount of parameters and runtime manageable, we follow the design of Ummenhofer \etal~\cite{}. The convolutional kernel of this network consists a pair of 1D filters in $y$ and $x$-direction, and the encoder gradually reduces the spatial resolution with stride of 2 while increasing the number of channels. We list the details of the network in our implementation details at \secref{sec:experiments}.

Additionally, after the output pose $\ve{p}_i$ from our pose network, as illustrated in \figref{fig:rnn}, a forward GRU-RNN is performed to model the temporal motion sequence of the video, since the movement of a vehicle is commonly smooth.
Traditionally in navigation applications of estimating 2D poses,  Kalman filter is applied by calculating either constant velocity or acceleration~\cite{}. 
In our case, transition of camera poses is learned from the training sequences, where the current motion is predicted by the RNN from a sequence of previous predicted poses, which yields further improvement over the estimated poses from the pose CNN.


\paragraph{Pose loss.} 
Following the PoseNet~\cite{}, we use the geometric matching loss for training, which avoids the balancing factor between rotation and translation. 
Formally, given a set of point cloud in 3D $~\hua{P}=\{\ve{x}\}$, and the loss for each image is written as,
\begin{align}
L(\ve{p}, \ve{p}^*) = \sum_{\ve{x} \in \hua{P}}\omega_{l_\ve{x}}|\pi(\ve{x}, \ve{p}) - \pi(\ve{x}, \ve{p}^*)|_2
\label{eq:proj_loss}
\end{align}
where $\ve{p}$ and $\ve{p}^*$ are the estimated pose and ground truth pose respectively. $\pi()$ is a projective function that maps a 3D point $\ve{x}$ to 2D image coordinates. $l_\ve{x}$ is the semantic label of $\ve{x}$ and $\omega_{l_\ve{x}}$ is a weight factor depended on the semantics. Here, we set stronger weights for point cloud belong to certain classes like traffic light, and we found it gives better performance for estimated poses.
In ~\cite{}, usually the 3D points that is visible by the camera are used which helps the stableness of learning. In our case, online searching the visible ones in millions of points are infeasible. 
Thus, we pre-render a depth map for each training image with resolution of $256 \times 304$, using the ground truth pose, and select those points projected on the depth map for training.

% Intuitively, we find the amount of points in each class is dramatically unbalanced, and most points are those on roads and trees. Nevertheless, the appearance variation of road and trees are not very sensitive to pose changes in the street-view scenario. In order to encourage the network to discover more str
% Thus,  other structures images like electricity pole or road light have rich structures like edges and textures, which potentially should be valued more for matching.
% In~\cite{ummenhofer2016demon}, the model try to predict a flow confidence map revealing the texture rich regions which helps pose estimation. In our work, we adopt the labelled semantic labels, and reweight each 3D point in the training loss, which drives the network to focus more on 
% Thus, the learning loss changed to 
% \begin{align}
% L(\ve{p}, \ve{p}^*) = \sum_{\ve{x} \in \hua{P}}\omega_{l_\ve{x}}|\pi(\ve{x}, \ve{p}) - \pi(\ve{x}, \ve{p}^*)|_2
% \label{eq:proj_loss}
% \end{align}
% where $\omega_{l_\ve{x}}$ is the weight of class $l_\ve{x}$. We set the weight for each class depends on the class edgeness which is the percentage of pixel along the edge 
\subsection{Video parsing with pose guidance}
Having rectified pose at hand, one may direct render the semantic 3D world to current view of a camera, yielding a semantic parsing of the current image. However, the estimated pose is not perfect, thus alignment of very think regions like light pole can totally fail. Another fact is that many LIDAR points are missing due to reflection, \eg regions of building mirrors, and points can be sparse at long distance. Finally, non-linear distortion of images and 3D map could happen due to system error, yielding scene miss alignment. Thus, we propose to a parameter light segment network to handle these issues. 
In our experiments, we show with pose rendered label map as an additional input, the segment results are temporally more consistent and yields better accuracy.

\begin{figure*}[]
\fbox{\rule{0pt}{2in} \rule{.9\linewidth}{0pt}}
   \caption{Architecture of the segment network.}
\label{fig:segment}
\end{figure*}
\paragraph{Segment network architecture.} As illustrated in \figref{fig:segnet}, the segment network contains an encoder-decoder network and a refinement network, and both have similar architecture with the corresponding ones used in DeMoN~\cite{ummenhofer2016demon}. 
The difference for encoder-decoder network is that for network inputs, rather than directly concatenate the label map with input image, to balance the two, we first transform the label map to a score map through one-hot operation, and embed the score of each pixel to a 32 dimensional feature vector. Then, we concatenate this feature vector with output features from those of the first layer, and keeps the rest as the same with that in~\cite{ummenhofer2016demon}. For refinement network, we use the same strategy to handle the two inputs. Finally, the segment network produce a score map, yielding the semantic label of each pixel.

We train the segment network firstly with only RGB images, then fine-tune the network by adding the input of rendered label maps. This is because our network is trained from scratch, thus needs large amounts of data to learn effective features from the image. However, in our experiments, the rendered label map from the estimated pose has on average 82$\%$ pixel accuracy. This could easily drive the network fitting the input label map at first, while slow down the process towards learning features from images. Finally, for segmentation loss, we use the standard softmax loss, and add intermediate supervision right after the output from encoder and decoder as indicated in \figref{fig:segment}.


\section{Experiments}
\label{sec:experiments}
\paragraph{Implementation details.} To quickly render from the 3D map, we adopt OpenGL to efficiently render a label map while handling the z-buffer operation. A 512 $\times$ 608 image can be generated in 70ms with a Titan Z GPU. 

\subsection{Ablation study.}

\paragraph{Pose Evaluation.}

\begin{table}
\center
\begin{tabular}{lccccc}
\toprule[0.2 em]
% \thickhline
Method &  & Camera pose & 3D map & Video per-frame labeling  & Temporal variations  \\ 
\hline 
\multicolumn{1}{l|}{CamVid~\cite{}}     &\checkmark                       & -              & -              &  -  & -  \\
\multicolumn{1}{l|}{KITTI~\cite{}}      &\checkmark  & \checkmark     & sparse points  & -   & -  \\
\multicolumn{1}{l|}{CityScapes~\cite{}} &\checkmark  & -              &  -             & selected frames & - \\
\multicolumn{1}{l|}{Toronto~\cite{}}    &\checkmark  & \checkmark     & sparse points  & selected pixels & - \\
\hline
\multicolumn{1}{l|}{Synthia~\cite{}}    & -          & \checkmark     & -       &\checkmark & -    \\ 
\multicolumn{1}{l|}{Play for benchmark~\cite{}} &-   & \checkmark     & -     &\checkmark & - \\
\hline 
\multicolumn{1}{l|}{Ours}              & Real        &\checkmark    &dense point cloud  & \checkmark     &  \checkmark \\
\toprule[0.2 em]
\end{tabular}
\caption{Compare our data with the other related outdoor street-view datasets for our task. 'Real Data' mean whether the data is collected from realistic world. 
'3D map' means whether it contains 3D map of the whole dataset. 'Video per-frame labeling' means whether it has per-frame per-pixel semantic label. 
'Temporal variations' mean whether the recorded video can roughly cover the whole scene, but have multiple.}
\label{tbl:data}
\vspace{-0.3\baselineskip}
\end{table*}

\paragraph{Segment Evaluation.}

\paragraph{Qualitative results.}

\paragraph{Discussion.}

\paragraph{Future work.} Since theoretically there exists optimal solutions which enforce the consistency between rendered label map from a camera pose and corresponding semantic segments, 
later we would like to design a real time solution for finding it for better localization.
In addition, we would like to model the surfaces which sketch out the 3D map, depend on our point cloud data, based on which a simpler and faster dense segment would performed.


\section{Conclusion}
\label{sec:conclusion}

% 
{\small
\bibliographystyle{ieee}
\bibliography{egbib}
}

\end{document}
